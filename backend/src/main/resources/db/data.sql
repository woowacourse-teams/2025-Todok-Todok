INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('오브젝트 - 코드로 이해하는 객체지향 설계',
'역할, 책임, 협력에 기반해 객체지향 프로그램을 설계하고 구현하는 방법, 응집도와 결합도를 이용해 설계를 트레이드오프하는 방법, 설계를 유연하게 만드는 다양한 의존성 관리 기법, 타입 계층을 위한 상속과 코드 재사용을 위한 합성의 개념 등을 다룬다.',
'조영호 (지은이)',
'위키북스',
'9791158391409',
'https://image.aladin.co.kr/product/19368/10/coversum/k972635015_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('클린 코드 Clean Code - 애자일 소프트웨어 장인 정신',
'로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 그는 오브젝트 멘토(Object Mentor)의 동료들과 힘을 모아 ‘개발하며’ 클린 코드를 만드는 최상의 애자일 기법을 정제해 책 한 권에 담았다.',
'로버트 C. 마틴 (지은이), 이해영, 박재호 (옮긴이)',
'인사이트',
'9788966260959',
'https://image.aladin.co.kr/product/3408/36/coversum/8966260950_2.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('클린 아키텍처 - 소프트웨어 구조와 설계의 원칙',
'소프트웨어 아키텍처의 보편 원칙을 적용하면 소프트웨어 수명 전반에서 개발자 생산성을 획기적으로 끌어올릴 수 있다. 《클린 코드》와 《클린 코더》의 저자이자 전설적인 소프트웨어 장인인 로버트 C. 마틴은 이 책에서 이러한 보편 원칙들을 설명하고 여러분이 실무에 적용할 수 있도록 도와준다.',
'로버트 C. 마틴 (지은이), 송준이 (옮긴이)',
'인사이트',
'9788966262472',
'https://image.aladin.co.kr/product/20232/24/coversum/8966262473_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('가상 면접 사례로 배우는 대규모 시스템 설계 기초',
'16가지 실제 시스템 설계 면접 문제와 상세한 답안을 제시한다. 시스템 동작 원리를 시각적으로 보여 주는 188개의 도해로 설명하면서 4단계 접근법으로 면접 문제를 풀 수 있도록 돕는다. 이 책을 통해 면접관이 평가하려는 항목과 그 이유를 내부자 관점에서 들을 수 있다.',
'알렉스 쉬 (지은이), 이병준 (옮긴이)',
'인사이트',
'9788966263158',
'https://image.aladin.co.kr/product/27604/17/coversum/8966263151_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('가상 면접 사례로 배우는 대규모 시스템 설계 기초 2 - 2024 우수학술도서',
'시스템 설계를 시작하는 사람들을 위한 가이드이자 설계 안내서이다. 1권에서 다루지 않았던 금융 시스템을 비롯해 보다 다양한 시스템을 사례로 들며 설계를 위해 필요한 지식을 설명한다. 또한 각 장마다 단계적 접근을 통해 실전에서 쓸 수 있는 전략을 알려 준다.',
'알렉스 쉬, 산 람 (지은이), 이병준 (옮긴이)',
'인사이트',
'9788966264254',
'https://image.aladin.co.kr/product/33040/41/coversum/8966264255_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('객체지향의 사실과 오해 - 역할, 책임, 협력 관점에서 본 객체지향',
'위키북스 IT Leaders 시리즈 23권. 객체지향이란 무엇인가? 이 책은 이 질문에 대한 답을 찾기 위해 노력하고 있는 모든 개발자를 위한 책이다.',
'조영호 (지은이)',
'위키북스',
'9788998139766',
'https://image.aladin.co.kr/product/6055/2/coversum/8998139766_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('스프링 입문을 위한 자바 객체 지향의 원리와 이해',
'위키북스 오픈소스 & 웹 시리즈 69권. 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량 애플리케이션 프레임워크인 스프링은 자바와 객체 지향이라는 기반 위에 굳건히 세워져 있다. 따라서 스프링을 제대로 이해하고 활용하려면 먼저 자바와 객체 지향부터 올바르게 이해해야 한다.',
'김종민 (지은이)',
'위키북스',
'9788998139940',
'https://image.aladin.co.kr/product/5564/19/coversum/8998139944_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('헤드 퍼스트 디자인 패턴 - 14가지 GoF 필살 패턴! 유지 관리가 편리한 객체지향 소프트웨어를 만드는 법, 개정판',
'하나의 패턴에 하나의 이야기를 담았다. 틀에 박히지 않아 지루할 틈이 없는 구성과 친구와 이야기하듯 편안한 대화체로 이야기를 풀어낸다. 이야기 속에 다양한 방법으로 해결할 수 있는 질문과 90개 이상의 연습문제를 담았다.',
'에릭 프리먼, 엘리자베스 롭슨, 케이시 시에라, 버트 베이츠 (지은이), 서환수 (옮긴이)',
'한빛미디어',
'9791162245262',
'https://image.aladin.co.kr/product/29089/24/coversum/k212837767_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('좋은 코드, 나쁜 코드 - 프로그래머의 코드 품질 개선법, 2023년 세종도서 학술부문 추천도서',
'구글 엔지니어가 말하는 좋은 코드 작성법. 좋은 코드를 작성하기 위한 이론과 실전을 소개한다. 단순히 해야 할 일과 하지 말아야 할 일을 나열하기보다, 여섯 가지 원칙을 바탕으로 각 개념과 기술의 장단점, 그리고 이면의 핵심 논리를 설명한다.',
'톰 롱 (지은이), 차건회 (옮긴이)',
'제이펍',
'9791191600896',
'https://image.aladin.co.kr/product/29464/92/coversum/k422837236_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('실용주의 프로그래머 20주년 기념판',
'실용주의 프로그래머 20주년 기념판. 데이비드 토마스와 앤드류 헌트는 소프트웨어 산업에 큰 영향을 미친 이 책의 1판을 1999년에 썼다. 고객들이 더 나은 소프트웨어를 만들고 코딩의 기쁨을 재발견하도록 돕기 위해서였다.',
'데이비드 토머스, 앤드류 헌트 (지은이), 정지용 (옮긴이), 김창준 (감수)',
'인사이트',
'9788966263363',
'https://image.aladin.co.kr/product/28878/64/coversum/8966263364_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('자바/스프링 개발자를 위한 실용주의 프로그래밍 - 객체지향부터 스프링과 테스트까지, 다시 제대로 배우는 애플리케이션 개발',
'자바 개발자가 코틀린 같은 신생 언어를 다룰 수 있게 된다고 해서 개발을 더 잘하게 되는 것은 아니다. 소프트웨어 개발 능력을 키우고 싶다면 ''개발'' 그 자체를 공부하고 기초적인 설계 원리를 이해할 수 있어야 한다. 이 책은 객체지향, SOLID, 디자인 패턴, 테스트 같은 주요 개발 관련 이론이 실제 프로젝트에 어떻게 적용될 수 있는지 설명한다.',
'김우근 (지은이)',
'위키북스',
'9791158395155',
'https://image.aladin.co.kr/product/34049/25/coversum/k452931274_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('리팩터링 2판 (리팩토링 개정판) - 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기',
'마틴 파울러의 『리팩터링』의 2판으로, 새로운 리팩터링 카탈로그를 자바스크립트 코드로 제시한다. 리팩터링 원칙부터 클래스 없이 리팩터링하는 방법과 데이터 조직화, 조건부 로직 간소화 방법을 다룬다. 또한 언어에 상관없이 리팩터링을 성공적으로 수행하는 실질적인 방법을 알려준다.',
'마틴 파울러 (지은이), 개앞맵시, 남기혁 (옮긴이)',
'한빛미디어',
'9791162242742',
'https://image.aladin.co.kr/product/23618/61/coversum/k932638523_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('코드 너머, 회사보다 오래 남을 개발자 - 소프트 스킬·개발문화·퍼스널 브랜딩으로 확보하는 결정적 경쟁력',
'개발 역량은 늘었는데 커리어는 제자리라면, 지금 필요한 건 더 많은 기술이 아니라 ''기술을 넘어선 힘''이다. 이 책은 개발자 커리어를 코드에만 의존하지 않고 다음 단계로 도약하는 구체적인 방법을 제시한다.',
'김상기, 배문교, 이동현, 이상아, 이수형, 차지현, 황성재 (지은이)',
'한빛미디어',
'9791169214032',
'https://image.aladin.co.kr/product/36680/81/coversum/k552030486_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('테스트 주도 개발',
'테스트 주도 개발은 테스트가 개발을 주도하는 방법이다. 테스트가 개발을 주도한다는 것은 테스트가 코딩의 방향을 이끌어 간다는 말이다.',
'켄트 벡 (지은이), 김창준, 강규영 (옮긴이)',
'인사이트',
'9788966261024',
'https://image.aladin.co.kr/product/3746/97/coversum/8966261027_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('테스트 주도 개발 시작하기 Test-Driven Development',
'작동하는 깔끔한 코드를 만드는 데 필요한 습관들을 담았다. JUnit 5를 이용한 테스트 주도 개발 안내, 테스트 작성과 설계를 위한 대역, 테스트 가능한 설계 방법 안내, 유지보수하기 좋은 테스트 작성법 등을 배울 수 있다.',
'최범균 (지은이)',
'가메출판사',
'9788980783052',
'https://image.aladin.co.kr/product/23361/46/coversum/8980783051_2.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('단위 테스트 - 생산성과 품질을 위한 단위 테스트 원칙과 패턴',
'단위 테스트에 대한 오해를 바로잡고, 올바른 단위 테스트에 대한 원칙, 테스트를 작성하는 스타일과 효과적인 테스트를 위한 소프트웨어 아키텍처를 이해할 수 있다. 또한 단위 테스트를 통합 테스트와 구분하고, 둘의 차이와 각각 활용법과 적절한 작성법, 안티 패턴 등을 알 수 있다.',
'블라디미르 코리코프 (지은이), 임준혁 (옮긴이)',
'에이콘출판',
'9791161755748',
'https://image.aladin.co.kr/product/28087/6/coversum/k942734842_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('토비의 스프링 3.1 Vol. 1 - 스프링의 이해와 원리',
'스프링을 처음 접하거나 스프링을 경험했지만 스프링이 어렵게 느껴지는 개발자부터 스프링을 활용한 아키텍처를 설계하고 프레임워크를 개발하려고 하는 아키텍트에 이르기까지 모두 참고할 수 있는 스프링 완벽 바이블이다.',
'이일민 (지은이)',
'에이콘출판',
'9788960773417',
'https://image.aladin.co.kr/product/1950/55/coversum/8960773417_2.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('토비의 스프링 3.1 Vol. 2 - 스프링의 기술과 선택',
'스프링을 처음 접하거나 스프링을 경험했지만 스프링이 어렵게 느껴지는 개발자부터 스프링을 활용한 아키텍처를 설계하고 프레임워크를 개발하려고 하는 아키텍트에 이르기까지 모두 참고할 수 있는 스프링 완벽 바이블이다.',
'이일민 (지은이)',
'에이콘출판',
'9788960773424',
'https://image.aladin.co.kr/product/1950/56/coversum/8960773425_2.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('코틀린 코루틴의 정석 - 기초부터 심화까지 알아보는, 2024년 대한민국학술원 우수학술도서 선정도서',
'많은 개발자들이 어렵게 느끼는 비동기 프로그래밍을 다양한 시각적 자료와 설명을 통해 누구나 쉽게 이해할 수 있도록 쓰인 책이다. 안드로이드, 스프링 등 코틀린을 사용하는 개발자들 중 코루틴을 사용한 비동기 프로그래밍을 기초부터 심화까지 제대로 배워보고 싶은 독자들에게 추천한다.',
'조세영 (지은이)',
'에이콘출판',
'9791161758251',
'https://image.aladin.co.kr/product/33413/26/coversum/k582938339_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('코틀린 아카데미 : 이펙티브 코틀린',
'코틀린의 60가지 효과적인 활용법을 알려 주는 실용적인 안내서이다. 단순히 언어의 기능을 아는 것을 넘어, 언제 어떻게 사용해야 하는지에 대한 깊이 있는 통찰을 제공한다. 다양한 코틀린 기능을 사용하여 안전성, 가독성, 유지보수성, 효율성 면에서 더 나은 코드를 만드는 방법을 제시한다.',
'마르친 모스카와 (지은이), 강진혁, 김보경 (옮긴이), 신성열 (감수)',
'인사이트',
'9788966264612',
'https://image.aladin.co.kr/product/36498/65/coversum/8966264611_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('이펙티브 자바 - 제3판',
'자바 플랫폼 모범 사례 완벽 가이드 ''이펙티브 자바''의 개정판. 3판에는 자바 7, 8, 9에서 자바 언어와 라이브러리에 추가된 특성들을 녹여냈다. 특히 그동안 객체 지향에 치중하던 자바에 새로 도입된 함수형 프로그래밍 요소도 자세히 알아본다.',
'조슈아 블로크 (지은이), 개앞맵시 (옮긴이)',
'인사이트',
'9788966262281',
'https://image.aladin.co.kr/product/17119/64/coversum/8966262287_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('모던 자바 인 액션 - 람다, 스트림, 함수형, 리액티브 프로그래밍으로 새로워진 자바 마스터하기',
'자바 최신 기능을 애플리케이션에 실용적으로 적용하는 방법을 알려준다. 수정처럼 투명한 예제와 꼼꼼한 정보 제공으로 여러분의 노력에 보답할 것이다. 또한 기존 핵심 자바의 지식뿐 아니라 스트림 API 등 읽기 쉽고 유지보수하기 쉬운 코드를 구현하는 데 어떻게 도움이 되는지 배울 수 있다.',
'라울-게이브리얼 우르마, 마리오 푸스코, 앨런 마이크로프트 (지은이), 우정은 (옮긴이)',
'한빛미디어',
'9791162242025',
'https://image.aladin.co.kr/product/20006/92/coversum/k042635140_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('자바 웹 프로그래밍 Next Step - 하나씩 벗겨가는 양파껍질 학습법',
'웹 개발 입문의 껍질(책에서는 ''양파껍질''로 표현한다)을 막 벗겨낸 경력 1년 이상의 초보개발자들을 대상으로 하는 책. 웹 서버, 프레임워크 등을 직접 제작해보고 테스트와 리팩토링을 통해 점진적 개선을 해나가면서 실무에 필요한 개발 능력과 웹에 대한 폭넓은 이해력을 높여준다.',
'박재성 (지은이)',
'로드북',
'9788997924240',
'https://image.aladin.co.kr/product/9150/19/coversum/8997924249_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('도메인 주도 개발 시작하기 - DDD 핵심 개념 정리부터 구현까지',
'가장 쉽게 배우는 도메인 주도 설계 입문서. 도메인 주도 설계(DDD)를 처음 배우는 개발자를 위한 책이다. 실제 업무에 DDD를 적용할 수 있도록 기본적인 DDD의 핵심 개념을 익히고 구현을 통해 학습할 수 있도록 구성했다.',
'최범균 (지은이)',
'한빛미디어',
'9791162245385',
'https://image.aladin.co.kr/product/29142/6/coversum/k262837077_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('도메인 주도 설계 - 소프트웨어의 복잡성을 다루는 지혜',
'도메인 주도 설계에 대한 체계적인 접근법을 제공하고 폭넓은 우수 설계 실천법과 경험을 토대로 한 기법, 복잡한 도메인에 직면한 소프트웨어 프로젝트의 발전을 가능하게 하는 근본 원칙을 제시한다. 설계 및 개발 원칙들이 한데 어우러져 있는 이 책에서는 현실세계의 소프트웨어 개발에 도메인 주도 설계를 응용한 모습을 생생하게 보여주는 실제 프로젝트에 기반한 수많은 예제가 실려 있다.\n\n',
'에릭 에반스 (지은이), 이대엽 (옮긴이)',
'위키북스',
'9788992939850',
'https://image.aladin.co.kr/product/1217/42/coversum/899293985x_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('소프트웨어 장인 - 프로페셔널리즘, 실용주의, 자부심',
'소프트웨어 장인에 대한 이야기. 프로그래머와 프로그래밍 관련 팀 또는 조직에 도움이 될만한 이야기를 풀어 놓았다. 생산성이 높은 프로페셔널, 자신의 일에 자부심을 갖는 프로페셔널로 도약하기 위해 필요한 계획, 전략, 태도, 원칙 등을 여러 가지 관점에서 조언했다.',
'산드로 만쿠소 (지은이), 권오인 (옮긴이)',
'길벗',
'9791186659489',
'https://image.aladin.co.kr/product/6692/58/coversum/k162434762_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('코딩을 지탱하는 기술 - 원리로 깨우치는 프로그래밍 기법',
'프로그래밍 언어가 가지고 있는 다양한 개념이 ‘왜’ 존재하고 있는지를 설명하는 책이다. 이를 위해 언어 설계자의 관점에서 여러 언어를 비교하고 언어가 어떻게 변화되어 왔는지를 설명한다.',
'니시오 히로카즈 (지은이), 김완섭 (옮긴이)',
'비제이퍼블릭',
'9788994774480',
'https://image.aladin.co.kr/product/3167/90/coversum/8994774483_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('CODE 코드 (화이트 에디션) - 하드웨어와 소프트웨어에 숨어 있는 언어, 2판',
'20년이 넘는 세월 동안 컴퓨터 공학 분야의 필독서로서 많은 독자를 열광하게 만든 《CODE》가 새로운 컴퓨팅 시대에 맞춰 개정되었다. 컴퓨터 내부의 비밀스러운 이야기들을 담은 이 책은 잘 짜인 일러스트와 이해하기 쉬운 설명을 통해서 컴퓨터에 대한 수수께끼를 풀어낸다.',
'찰스 펫졸드 (지은이), 김현규 (옮긴이)',
'인사이트',
'9788966264285',
'https://image.aladin.co.kr/product/33030/17/coversum/896626428x_2.jpg',
CURRENT_TIME,
CURRENT_TIME);

-- 29
INSERT INTO BOOK (title, summary, author, publisher, isbn, image, created_at, modified_at)
VALUES
('엘레강트 오브젝트 - 새로운 관점에서 바라본 객체지향',
'기본적으로 객체지향 프로그래밍((Object-Oriented Programming, OOP)에 관한 책이다. 이 책은 전통적인 OOP의 모범 사례에 전면적으로 반기를 들고 전통적인 코딩 표준에서 벗어나 훨씬 깨끗한 코드 작성을 위한 조력자임을 자처한다.',
'Yegor Bugayenko (지은이), 조영호 (옮긴이)',
'지&선(지앤선)',
'9791187497219',
'https://image.aladin.co.kr/product/25837/40/coversum/k762736538_1.jpg',
CURRENT_TIME,
CURRENT_TIME);

--유저
INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('chanho680526@gmail.com',
'페토',
'https://user.png',
'페토 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

-- 2
INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('wondroid.world@gmail.com',
'모찌',
'https://user.png',
'모찌 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('donghyunyoon81@gmail.com',
'동전',
'https://user.png',
'동전 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('ljhee92.sist@gmail.com',
'듀이',
'https://user.png',
'듀이 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('kingjh1125@gmail.com',
'링크',
'https://user.png',
'링크 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('chaeyoung0714@gmail.com',
'모다',
'https://user.png',
'모다 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO MEMBER (email, nickname, profile_image, profile_message, created_at, modified_at)
VALUES
('quantumjump10@gmail.com',
'제프',
'https://user.png',
'제프 상태 메시지 입니다',
CURRENT_TIME,
CURRENT_TIME);

--토론방
-- 1
INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('엘강오 생성자 관련 토론',
'저는 주로 생성자에서 검증을 하는 편인데, 코드를 넣지 말라고 하면 객체 필드에 대한 검증 로직은 어디에 들어가는 게 적합할까요?',
2, 29,
CURRENT_TIME,
CURRENT_TIME);

-- 2
INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('필드가 없는 클래스 == 객체?',
'엘강오에서는 최소한 뭔가는 캡슐화하라고 했는데, 그렇다면 캡슐화할 필드가 없는 클래스는 객체라고 불릴 수 없는걸까요?',
5, 29,
CURRENT_TIME,
CURRENT_TIME);

-- 3
INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('확장성과 복잡성의 트레이드 오프에 대해',
'모든 상황에서 확장성을 고려하여 인터페이스를 사용해야 할까요? 인터페이스를 사용하는 것이 오버 엔지니어링은 아닐까요? 확장성과 복잡성의 트레이드 오프를 어느 정도까지 잡아야 할지 모르겠습니다.',
5, 29,
CURRENT_TIME,
CURRENT_TIME);

-- 4
INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('getter는 절대 사용하면 안 되는가?',
'getter를 절대 사용하지 않는다면 서로 책임을 넘기느라 객체 그래프가 과도하게 깊어져 오히려 복잡성이 늘어나는 경우가 생기는데, 이런 경우에도 쓰지 않는 것이 좋을까요? 어느 정도까지 getter를 쓰지 않는 것을 고려해야 할까요?',
1, 29,
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('데이터와 프로세스를 한 단위에서 묶는 것이 어째서 편협한 시각일까?',
'28P
"객체 지향 프로그래밍을 흔히 데이터와 프로세스를 하나의 단위로 통합해 놓은 방식으로 표현하기도 한다.
비록, 이 관점이 객체지향을 구현 관점에서 바라본 지극히 편협한 시각인 것은 맞지만, (~이하 생략)"

오브젝트에선 데이터와 프로세스를 한 단위로 묶는 것을, 객체 지향을 구현 관점으로만 본 편협한 시각이라 이야기합니다.

객체 지향을 구현함에 있어 자주 잊어버리는 실수라 생각합니다.
그렇기에 이 문제를 정의하고 넘어가면 좋다고 생각했어요. 😎',
1, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('객체는 어느 정도까지 의인화할가?',
'객체지향에서 객체를 살아 숨쉬는 존재로 보기 때문에 객체를 의인화 한다고 표현하는데요.
여러분은 객체를 어느 정도까지 의인화하시는지 궁금합니다.',
2, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('변경에 유연한 코드란 무엇일까?',
'변경에 유연한 코드란 무엇을 의미할까요?
변경을 예측하여 작성한 코드와는 다른 것일까요?

❓ 이유
저는 변경에 유연한 코드와 변경(미래)을 예측하여 작성한 코드는 전혀 다르다고 생각합니다.

제가 생각하는 변경에 유연한 코드를 작성하는 방법 중 하나는 static 클래스를 지양하는 것입니다.
저는 주로 OutputView와 같은 클래스를 static하게 작성했는데요.
하지만 추후 콘솔이 아닌 모니터에 출력해야 한다면, 혹은 상황에 따라 출력 방식이 달라진다면 어떻게 해야할까요?
출력에 관한 여러 구현체를 만들어야하고 필요에 따라 구현체를 갈아 끼워 넣어야할 것입니다.

만약 OutputView를 객체로 생성하여 사용했다면 추후 어떤 변경이 생기던 간에 새로운 구현체를 생성해 넣어줌으로써 변경에 쉽게 대처할 수 있을 것입니다.
이러한 이유로 static하게 작성된 클래스는 객체지향스럽지 못하고 변경에 유연하지 못하다고 생각합니다.',
 3, 1, CURRENT_TIME, CURRENT_TIME);

 INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
 VALUES
 ('메세지와 메서드의 차이가 무엇인가요?',
'저는 지금까지 메시지와 메서드를 구분하지 않고 사용하고 있었던 것 같아요.
그래서 다형성에 대한 이해도가 낮았던 것 같습니다.
여러분도 메시지와 메서드의 차이점, 그리고 다형성에 대해 제대로 이해하고 계시는지 이야기 나누어보면 좋을 것 같습니다.

📖 관련 페이지
p.49 협력에 관한 짧은 이야기',
4, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('객체지향 패러다임이 강력한 이유?',
'41p [도메인의 구조를 따르는 프로그램 구조]
"객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.
요구사항과 프로그램을 객체라는 동일한 관점에서 볼 수 있기 때문에..."

-> 저는 객체지향 패러다임이 왜 강력한지에 대한 설명이 이해되지 않습니다.
이 내용이 어떤 의미를 담고 있는지, 대화를 통해 함께 풀어보고 싶습니다.',
1, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('컴파일 의존성과 실행 의존성이 다르면 유연한 설계일까?',
'책을 읽던 중 모호한 부분이 생겨서 이슈를 올립니다!

73p "유연한 객체지향 프로그램을 위해서는 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다는 사실 역시 알게 됐다."

책에서는 "유연한 객체지향 프로그램을 위해서는 ~~ 의존성이 달라야 한다는 사실" 이라고 적혀있습니다. 뭔가, "유연한 설계는 컴파일, 런타임 시간 의존성이 달라야 하나?" 라는 생각이 들며 어색했습니다. 이에 내용을 읽고 느낀 여러분의 의견이 궁금합니다.',
1, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('메세지가 객체를 결정하게 하는 것이 맞을까?',
'ch4를 읽다가 메시지를 먼저 정의하고, 객체를 결정하는 방식의 설계에 대해 의문이 생겼습니다.

저는 보통 요구사항을 분석한 뒤, 필요한 행동들을 먼저 도출하고, 그 행동들을 묶어서 객체를 설계하는 방식으로 진행해왔습니다. 반면 저자는 메시지를 먼저 정의하고, 그 메시지를 전달받아 처리할 객체를 선택하는 흐름으로 설계합니다. 이 방식이 객체를 더 작고 유연하게 만들 수 있다는 장점은 있지만, 책임이 작게 나누게 되면 복잡도가 증가하는 게 아닌가라는 의문이 들었습니다. 그래서 제가 궁금하게 된 것은 다음과 같습니다.

객체를 잘게 나누었다가 합친 경우가 있다면, 객체를 합치는 기준은 무엇인가요?

메시지 기반으로 설계를 해본 경우가 있다면, 기존의 미션이나 설계에서 어떠한 생각의 흐름으로 되었는지 궁금합니다.메시지의 방식으로는 설계의 흐름을 잡기가 어렵다고 느껴져서 다른 사람들은 어떻게 적용하는지 궁금합니다. 메시지를 어떻게 만들어내고 객체를 설계했다는 예시가 있다면 감사하겠습니다!',
1, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
('응집도와 결합도의 차이?',
'응집도와 결합도가 어떤 차이를 가지는 지에 대한 다른 분들의 생각이 궁금합니다.
응집도는 내부에 얼마나 비슷한 책임들이 모여있는가, 결합도는 책임이 얼마나 외부에 새어 나가지 않았는가라는 관점의 차이만 존재한다고 느꼈습니다.

제가 인지하지 못한 추가적인 차이가 존재할까요?',
1, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
    ('엘강오 생성자 관련 토론',
     '저는 주로 생성자에서 검증을 하는 편인데, 코드를 넣지 말라고 하면 객체 필드에 대한 검증 로직은 어디에 들어가는 게 적합할까요?',
     2, 29,
     CURRENT_TIME,
     CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
    ('필드가 없는 클래스 == 객체?',
     '엘강오에서는 최소한 뭔가는 캡슐화하라고 했는데, 그렇다면 캡슐화할 필드가 없는 클래스는 객체라고 불릴 수 없는걸까요?',
     5, 29,
     CURRENT_TIME,
     CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
    ('확장성과 복잡성의 트레이드 오프에 대해',
     '모든 상황에서 확장성을 고려하여 인터페이스를 사용해야 할까요? 인터페이스를 사용하는 것이 오버 엔지니어링은 아닐까요? 확장성과 복잡성의 트레이드 오프를 어느 정도까지 잡아야 할지 모르겠습니다.',
     5, 29,
     CURRENT_TIME,
     CURRENT_TIME);

INSERT INTO DISCUSSION (title, content, member_id, book_id, created_at, modified_at)
VALUES
    ('getter는 절대 사용하면 안 되는가?',
     'getter를 절대 사용하지 않는다면 서로 책임을 넘기느라 객체 그래프가 과도하게 깊어져 오히려 복잡성이 늘어나는 경우가 생기는데, 이런 경우에도 쓰지 않는 것이 좋을까요? 어느 정도까지 getter를 쓰지 않는 것을 고려해야 할까요?',
     1, 29,
     CURRENT_TIME,
     CURRENT_TIME);

--한 토론방 마다 댓글 0, 1, 2개
--INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
--VALUES
--('상속의 핵심 목적은 타입 계층의 구축입니다!',
--1, 2,
--CURRENT_TIME,
--CURRENT_TIME);
--
--INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
--VALUES
--('상속의 핵심 목적은 타입 계층의 구축입니다!',
--1, 3,
--CURRENT_TIME,
--CURRENT_TIME);
--
--
--INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
--VALUES
--('상속의 핵심 목적은 타입 계층의 구축입니다!',
--2, 3,
--CURRENT_TIME,
--CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('어차피 캡슐화를 생각한다면 밖에서는 필드의 존재를 몰라야 하는 게 맞고, 메세지로만 객체가 행동하기 때문에 객체라고 불릴 수 있다고 생각해요. 다른 분들의 의견은 어떤가요?',
3, 2,
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('그래도 항상 인터페이스를 사용하는 것이 좋지 않을까요? 언제, 어디서 요구사항이 바뀔지 모르는데 이에 대한 대비를 해두는 것은 향후 유지보수성에 좋다고 여겨집니다.',
3, 3,
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 간단한 프로그램임에도 인터페이스를 넣으니 오히려 불편했어요. 확실히 확장성이 없다고 느껴지는데도 굳이 인터페이스를 넣어야 할까요?',
4, 3,
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('getter를 "절대"사용하지 않아야 한다는 것은 말이 안 되는 것 같아요. 편하자고 정해둔 것일 뿐, 목적에 따라 적절히 사용해도 괜찮다고 생각합니다.',
3, 4,
CURRENT_TIME,
CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('좋은 주제네요!
저는 사실 바로 필요성이 보이지 않는 부분이라면 굳이 고려하지 않는 편이긴 해요
직접 그 불편함을 느껴봐야 어느 정도까지 유연한 코드를 작성할 수 있을지 기준이 세워질 것 같은데 아직은 느껴본 적이 없긴 하네요😅

 그래서 당장은 기술적으로 변경에 유연한 코드를 작성하기 보다는 최대한 읽기 좋은 코드를 작성하는 것이 변경에 유연한 코드를 작성하는 것 아닐까 생각되긴 해요

 작성했던 코드를 변경하게 된다는 건 요구사항이 변했다는 뜻이고, 기존 요구사항에 따라 작성한 코드를 읽고 변경점이 어디인지 잘 찾아내는 것도 변경에 유연한 방법이 될테니까요!',
5, 3, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저도 이번 ch2를 읽으면서 메세지와 메서드에 대한 내용이 꽤나 인상 깊었는데요~
머리로는 이해했지만 다시 저만의 언어로 표현하고자 하니 쉽지 않네요.

우선 메세지는 객체가 외부에게 제공하는 인터페이스에 해당하는 것이고,
메서드는 메세지를 호출했을 때 실제로 수행되는 것이라고 설명할 수 있을 것 같아요.

더 단순하게 컴파일 시점에 호출하는 것을 메세지, 런타임 시점에 실행되는 것을 메서드라고 할 수도 있겠네요.

호출한 것과 실제로 실행되는 것이 다르다는 말은 하나의 행동이 다양한 방법으로 수행될 수 있다는 것을 의미하고,
이것이 곧 다형성이라고 생각합니다.

정리하자면 다형성은
동일한 행동(메세지)에 대해 다양한 방법(메서드)으로 수행될 수 있는 것이라고 말할 수 있을 거 같아요.',
5, 4, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('코드 작성 시점에 호출하는 것이 메세지, 실제 실행되는 것을 메서드?',
 6, 4, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('객체 지향이 아닌 절차 지향 언어로 프로그램을 구현했다면 어땠을 지를 생각해보면 좋을 것 같아요.

우리는 현실 세계를 객체로 추상화하여 바라볼 수 있는 능력을 지니고 있습니다.
하지만 설계와 구현에 들어서는 순간부터는 객체 관점을 유기하고 절차 지향적인 코드를 떠올려야 하겠죠?

객체 지향 언어를 사용한다면 우리가 바라본 객체의 세계를 기반으로 설계하고, 더 나아가 구현까지 할 수 있습니다.
객체 세계를 절차 지향적으로 옮겨 놓은 것보다는 객체 관점 그대로 구현한 코드가 훨씬 읽기 쉽겠죠?

그러한 의미에서 객체 지향 패러다임이 매끄럽게 연결될 수 있고 강력하다고 생각해요.',
6, 5, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('해당 내용에서 말하는 객체 지향의 강점은 요구사항 분석부터 구현까지 동일한 추상화 단위(객체)를 사용한다는 점이라 생각합니다.
즉, 요구사항과 구현 단위가 같아 직관적이라는 뜻입니다.

예를 들어 “계좌는 입금, 출금 기능을 수행한다”는 요구가 있을 때,
절차 지향은 데이터(계좌)와 로직(입출금)이 분리되고, 요구사항 하나가 여러 구현 단위로 흩어집니다.
→ 복잡해질수록 구현 지점을 찾기 어려워집니다.

반면 객체 지향은 계좌 객체가 스스로 입출금 기능을 수행합니다.
요구사항이 코드 구조에 그대로 반영되기 때문에 이해와 수정이 훨씬 직관적입니다.

이런 점이 객체 지향의 진짜 강점 아닐까 싶습니다.',
7, 5, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('컴파일 의존성과 실행 의존성이 다르다는 것은 책에 나와 있는 예를 들어 본다면 컴파일 시점에는 DiscountPolicy를 사용하여 의존하고, 런타임 시점에는 AmountDiscountPolicy를 사용하여 의존하는 것을 의미한다고 생각했어요.
 그래서 유연한 설계 == 역할을 잘 추상화한 설계 라고 생각하면서 책을 읽었고요!
 작성자분은 왜 어색하다는 생각이 들었나요?',
6, 6, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('이는 해당 문구가 "유연한 설계를 위해서는 컴파일, 런타임 시간 의존성이 달라야만 한다" 라고 느껴지는 부분 때문인가 싶습니다.
 1. 컴파일 시간 의존성과 실행 시간 의존성이 다르면 유연한 객체지향 프로그램을 할 수 있다.
 2. 유연한 객체지향 프로그램을 위해서는 컴파일 시간 의존성과 실행 시간 의존성이 달라야 한다.

사실 같은 의미지만, 워딩의 차이가 좀 더 의심스럽게 만드는 것 같네요.
결국 1번은 사실이면, "컴파일 시간 의존성과 실행 시간 의존성이 다르다"는 유연함에 +인 요소입니다.
대신 더 복잡한 코드가 된다던가, 다른 지점에서 - 요소를 가지고 있을테니 단언할 수 없지 않느냐? 는 것인데-
이는 유연함과 다른 일면에서의 단점이기 때문에 서로 분리해서 고려하면 좋을 것 같다 생각해요..!',
1, 6, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('반드시 유연한 설계는 컴파일과 런타임 의존성이 다를 필요는 없습니다.
다만, 코드라는 것은 이미 만들어진 것을 돌아가고 있기에 컴파일 단계에서는 유연함을 표현하기가 어렵다고 생각합니다.
언어가 제공하는 다형성을 사용해 컴파일에서는 변경되지 않는 것에 의존하고, 런타임에서 구현체를 주입하거나 변경하여 동작을 변경 가능하게 설계한다면 코드의 확장성과 유지 보수에 도움이 된다고 생각합니다.',
 7, 6, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 객체에게 책임이 적절하게 할당되었다면 합치지 않아도 된다고 생각해요. 지금까지는 객체를 분리해본 적만 있지, 합쳐본 적은 없는 듯 합니다.',
 2, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('작성자분이 요구사항을 분석한 뒤, 필요한 행동들을 먼저 도출했다고 했는데요. 여기서 도출한 행동이 메시지가 아니라 실제 내부 상세 구현인가요? 실제 내부 상세 구현이 아니라 예를 들어 ''가격을 결정한다'' 혹은 ''영화를 예약한다''와 같은 행동이라면 저자가 말하는 메시지와 동일하다고 볼 수 있지 않을까요?',
 3, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('행동과 메시지가 많이 헷갈려지긴 합니다. 블랙잭 미션에서 참가자가 카드를 뽑는다, 참가자는 카드를 합을 반환한다. 이렇게 행동을 정리하여서 객체를 설계하였는데 이러한 설계가 메시지라고 볼 수 있는 걸까요?',
 4, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저도 두번째 댓글 작성자분과 같은 의견입니다.
카드를 뽑는다 혹은 카드를 받는다는 행동이자 메세지, 둘 다라고 생각합니다.',
 5, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('헷갈리는 부분이네요. 저자가 말한 방식은 메시지를 먼저 설계하고, 그 후 메시지를 보내는 객체와 받는 객체를 선택하는 것이라고 보았습니다.
 반면, 저의 방식은 요구사항에서 행동을 도출한 뒤, 그 행동을 수행하는 하나의 객체를 중심으로 설계했다고 생각합니다.',
 1, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저 또한, 책에서 저자는 메시지, 행동, 역할, 협력 등의 단어를 번복해 내용을 서술해 갑자기 혼동이 발생하는 경우도 있었습니다.

1번
메시지로 협력 관계를 도출했으면, 표현해주신 객체간에 합쳐진다(?)는 이미 정의가 되어 있다고 생각합니다. 그래서 저도 분해해본적은 있지만, 합쳐본 경우는 없습니다.
작성자분이 기존에 하던 설계 방식은 행동을 나눌때, 객체 하나만 바라보는 설계를 하나요? "난 이 객체가 필요해, 이 객체는 어떤 메시지이지?" 이런 접근으로 한다면 합치는 과정이 생길 수 있네요. 🤔

2번
요구 사항을 읽고, 객체 간의 협력을 조성하기 위해 메시지를 생각해봅니다.

요구 사항
플레이어는 카드를 추가로 지급 받는다

고민 과정
필요한 메시지는 "카드를 발급한다", "카드를 저장한다" 등으로 큰 타이틀의 메시지로 시작해. 메시지에 필요한 또 다른 새로운 메시지를 낳으면서 세계를 만들어갑니다. 그 후, 공통되는 메시지로 협력할 수 있는 객체 세상을 추상화하는 과정을 거칩니다!',
 6, 7, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('데이터와 프로세스를 묶어서 처리하게 된다면 해당 필드가 가지고 있는 것 때문에 너무 많은 책임이 부여될 수도 있습니다.
예를 들어, 블랙잭에서 List Card가 있는 클래스가 있다고 치면, 참가자들도 카드를 가지기에 List Card를 가질 수 있고, 카드에 대한 덱도 List Card를 가지고 있습니다. 만약, 이러한 List Card라는 것을 중점적으로 생각하게 된다면, 참가자가 카드 덱도 뽑는 책임도, 덱을 위해 카드를 주입하고 넣는 행위도 중첩되어 여러 가지 책임을 가지게 될 수 있습니다. 이는 변경에 취약해지고 유지 보수하기가 어려워질 수도 있다고 생각합니다
그렇기에 데이터적인 사고를 하기 보다는 객체에 책임을 고민하고 분리하게 된다면 객체 지향적인 코드를 만들어 낼 수 있다고 생각합니다!',
 2, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('객체가 가지고 있는 데이터는 단순히 행동을 위해 가지고 있는 것이기 때문에 데이터와 행동을 단순히 한 단위로 묶어서 생각하는 것은 편협한 생각이라고 볼 수 있을 것 같아요.
 데이터와 행동이 항상 1:1 매핑되는 것이 아니기도 하고요. 가지고 있는 데이터가 객체의 행동1(책임1)에 필요할 수도 있고~ 행동2(책임2)에 필요할 수도 있을테니까용

객체지향을 처음 접하는 사람이라면 객체를 데이터와 행동으로 묶어 생각할 수 있겠지만, 행동(책임) 위주로 객체를 바라보게 된다면 왜 편협하다고 말하는지 이해할 수 있지 않을까요?',
 3, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 편협한 생각이라는 단어가 어색해 사전을 찾아봤습니다. 정의는 "한쪽으로 치우쳐서 전체를 제대로 보지 못하는 상태" 라고 적혀있었습니다.

앞선 댓글이 얘기 해준 거 처럼 객체 지향을 처음 접하는 사람이라면 단순히 객체를 데이터와 행동으로 묶어 생각할 수 있습니다. 🤔

하지만, 이와 같은 시선은 다른 큰 요소를 놓칠 수 있다고 생각합니다. ⚠️

객체지향에는 중요한 4가지 요소인
다형성
캡슐화
추상화
상속
이 있습니다. 하지만, "데이터와 행동은 묶어 생각한다는" 의미는 캡슐화만 고려한다는 느낌이 강합니다.

만약, 주제 관점에서 객체를 설계한다고 하면 캡슐화 유지를 가능할 수 있지만, 다른 요소들을 충분히 놓칠 수 있다고 생각해 편협한 생각이라 생각합니다.',
 4, 1, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('어려운 주제네요.
저는 주로 객체의 책임을 먼저 생각해보고 그에 따른 의인화를 하는 거 같아요.

장기 미션을 예로 들면, 기물이 자신의 위치를 관리하는 책임을 가져야 할까 생각해보았을 때 아니라고 판단했습니다.
(그 이유를 물어본다면 그냥 직감이었던 거 같아요)

이후 보드가 보드판 위의 여러 Piece들을 관리하는 책임을 가진다고 보아서 보드가 기물들을 움직이게끔 의인화했습니다.

이 이슈에 대한 답을 남에게 설명할만큼 확고한 기준을 가지고 있지 않아 글로 표현하기 어렵네요!
다른 분들의 의견도 궁금합니다~',
 3, 2, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 그 객체 자체를 사람으로 만든다! 보단 그 객체마다 담당자가 있다고 생각했어요!

오브젝트의 예시엔 Bag이라는 객체가 있습니다.
저는 가방을 인간으로 생각하는 것 대신, 가방을 든 사람에게 가방의 로직을 맡긴다고 생각해요!

예를 들어 엘리베이터라는 객체는 엘리베이터 버튼을 눌러주는 벨보이? 같은 사람이 내부에서 작업해주는 것이죠!
마치 햄스터들이 로봇 안에서 조종하고 있는 그런 느낌,,,
그래서 객체 개념 자체를 의인화하기보다, 객체마다 담당자가 로직을 토대로 문제를 해결하는 것이, 제가 이해하기 쉬운 방향이었어요!',
 4, 2, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('질문의 의도가 궁금해집니다! 🤔

의인화는 "객체를 살아 숨쉬는 존재" 라고 생각합니다.
작성자 분이 생각하는 살아 숨쉬는 존재는 움직임과 객체의 살아 숨쉬는 정의가 살짝 헷갈린 거 같다고 생각합니다.

기물이 움직이지 않지만, 기물은 스스로 검증하고, 위치를 가지고 있습니다.
저는 이점에서 충분히 기물은 의인화 되어서 객체 세상에서만의 숨을 쉬고 있다고 생각해요! ☺️',
 5, 2, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('아직은 모두가 의인화에 대한 기준을 잡기가 어렵다고 생각해요.
 설계를 많이 하다 보면 본인만의 객체의 의인화 기준을 잡아나갈 수 있을 것 같아요! (경험의 중요성!)',
 2, 2, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 변경에 유연한 코드는 캡슐화가 잘된 코드라 생각합니다.
적절한 객체에게 적절한 책임을 부여했을때,
객체는 아는 것과 하는 것을 정의합니다.

변경 사항에 대하여 어느 객체가 아는 사항인지,
그리고 어느 객체가 하는 것인지 구별할 수 있게 됩니다.

그럼 저희는 요구사항대로 그 부분만 변경하면 되는 것이죠.

이것이 캡슐화된 코드가 변경에 대한 비용을 줄이는 이유라 생각합니다.
이는 변경을 예측하는 것과 다릅니다. 엄연히, 정의된 책임을 수행하는 객체이죠.
그렇기에, 배경으로 책임이 명확하지 않다면,오버엔지니어링이 될 수 있습니다.
이러한 맥락을 지키기 위해, 저는 객체의 책임에 집중합니다.특히, 아는 것과 하는 것을 정의하죠. (필드와 메서드)
만약, 아는 것이 변한다면 의존성을 어떻게 주입할지,
그 책임은 누가 가지는지 고민할 겁니다.

그 상황에 맞는 설계를 고려하는 것이 유연한 코드 작성법이라 생각합니다🤔
너무 당연한 말일 수 있지만,,,😅
디자인 패턴을 적절히 써야한다는 같은 말인거죠..!😚',
 4, 3, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저 또한, 응집도와 결합도가 궁극적으로 유사한 개념이라 생각했습니다.
캡슐화라는 상위 개념이 존재하고, 하위 개념으로 동등한 수준의 응집도와 결합도가 존재합니다.
이때, 응집도와 결합도는 객체의 품질을 평가하기 위해 바라보는 관점에 차이를 두기위해 나눈 것입니다.

그렇다면, "높은 응집도와 높은 결합도" 같은 경우가 있는지 궁금하네요.
로깅 시스템 같은 인프라 컴포넌트는 자신의 책임에 매우 집중되어 있어 응집도가 높습니다.
그러나 이런 컴포넌트는 시스템의 많은 부분에서 사용되므로 높은 결합도를 가질 수 있습니다.
(로깅 서비스는 로깅이라는 하나의 책임에 집중(높은 응집도)하지만, 시스템 전체 클래스들과 연결됨(높은 결합도))

이러한 맥락을, 객체가 적절한 책임을 가진다 하더라도 피치 못하게 강한 결합도를 가지는 경우! 로 볼 수 있을까요🤔🤔',
 7, 8, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('오~ 위의 댓글이 말해준 예시처럼 높은 응집도, 높은 결합도가 존재할 수도 있겠네요!
결합도를 외부에 책임이 샜다는 관점에서만 바라보는 제 기존 생각은 적절하지 않았다고 생각이 드네요.
좋은 설명과 예시👍🏻',
 3, 8, CURRENT_TIME, CURRENT_TIME);

INSERT INTO COMMENT (content, member_id, discussion_id, created_at, modified_at)
VALUES
('저는 응집도를 객체 내부에 얼마나 관련 있는 책임이 모여있는가, 결합도를 객체끼리 얼마나 최소한으로 의존하고 있는가 라고 이해했어요
응집도는 객체 하나만의 관점으로 바라보고, 결합도는 협력을 하는 여러 객체의 관점에서 바라보는 것으로요!',
 4, 8, CURRENT_TIME, CURRENT_TIME);

 INSERT INTO REPLY (content, member_id, comment_id, created_at, modified_at)
 VALUES
 ('저도 동의합니다!!',
  4, 19, CURRENT_TIME, CURRENT_TIME);
